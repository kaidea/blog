import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.82dd189e.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/react/basic/react.md","filePath":"docs/react/basic/react.md"}'),p={name:"docs/react/basic/react.md"},o=l(`<h3 id="下面的jsx-代码中-那一个无法达到预期效果" tabindex="-1">下面的jsx 代码中,那一个无法达到预期效果? <a class="header-anchor" href="#下面的jsx-代码中-那一个无法达到预期效果" aria-label="Permalink to &quot;下面的jsx 代码中,那一个无法达到预期效果?&quot;">​</a></h3><ol><li><code>&lt;h2&gt;hellow world&lt;/h2&gt;</code></li><li><code>&lt;input type=&quot;checkbox&quot;/&gt;</code></li><li><code>&lt;div class=&quot;msg-box&quot;&gt;{msg}&lt;/div&gt;</code></li><li><code>&lt;label htmlFor=&quot;name&quot;&gt;leo&lt;/label&gt;</code></li><li><code>&lt;div style={height:50}&gt;&lt;/div&gt;</code></li><li><code>&lt;img src={imgSrc}&gt;</code> 答案:3</li></ol><h3 id="什么时候使用状态管理器" tabindex="-1">什么时候使用状态管理器? <a class="header-anchor" href="#什么时候使用状态管理器" aria-label="Permalink to &quot;什么时候使用状态管理器?&quot;">​</a></h3><ol><li>通过提升单个组件的复杂度,实现组件通讯</li><li>有相当大量的，随时间变化的数据</li><li>state需要有一个单一可靠数据源</li><li>所有state放在顶层组件已经无法满足需求了</li><li>要维护大量与服务器交互的数据</li><li>当状态提升提升不能够满足开发需求，状态树并不总是以一种线性的，单向的方式流动。就需要使用状态管理器。</li></ol><p>从项目的整体看 1.用户的使用方式复杂 2.不同身份的用户有不同的使用方式（比如普通用户和管理员） 3.多个用户之间可以协作 4.与服务器大量交互，或者使用了WebSocket 5.View要从多个来源获取数据</p><p>从组件角度看 1.某个组件的状态，需要共享 2.某个状态需要在任何地方都可以拿到 3.一个组件需要改变全局状态 4.一个组件需要改变另一个组件的状态</p><h3 id="render函数中return如果没有使用-会有什么问题" tabindex="-1">render函数中return如果没有使用()会有什么问题？ <a class="header-anchor" href="#render函数中return如果没有使用-会有什么问题" aria-label="Permalink to &quot;render函数中return如果没有使用()会有什么问题？&quot;">​</a></h3><blockquote><p>我们在使用JSX语法书写react代码时，babel会将JSX语法编译成js，同时会在每行自动添加<strong>分号</strong>（；），如果<code>return</code>后换行了，那么就会变成 <code>return；</code> 一般情况下会报错：</p><ul><li><strong>Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.</strong></li></ul><p><strong>上面这段英文翻译成中文：</strong></p><ul><li>渲染没有返回任何内容。这通常意味着缺少return语句。或者，为了不渲染，返回null。</li></ul><p>为了代码可读性我们一般会在return后面添加括号这样代码可以折行书写，否则就在return 后面紧跟着语句，这样也是可以的。</p><p>举两个正确的书写例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Nav</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">nav</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">className</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;c_navbar&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      { some jsx magic here }</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#85E89D;">nav</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  )</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Nav</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> &lt;</span><span style="color:#85E89D;">nav</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">className</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;c_navbar&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    { some jsx magic here }</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#85E89D;">nav</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Nav</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">nav</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;c_navbar&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      { some jsx magic here }</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/</span><span style="color:#22863A;">nav</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  )</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Nav</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> &lt;</span><span style="color:#22863A;">nav</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;c_navbar&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    { some jsx magic here }</span></span>
<span class="line"><span style="color:#24292E;">  &lt;/</span><span style="color:#22863A;">nav</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>错误的写法：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Nav</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">nav</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">className</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;c_navbar&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      { some jsx magic here }</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#85E89D;">nav</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Nav</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">nav</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;c_navbar&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      { some jsx magic here }</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/</span><span style="color:#22863A;">nav</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></blockquote><h3 id="componentwillupdate可以直接修改state的值吗" tabindex="-1">componentWillUpdate可以直接修改state的值吗？ <a class="header-anchor" href="#componentwillupdate可以直接修改state的值吗" aria-label="Permalink to &quot;componentWillUpdate可以直接修改state的值吗？&quot;">​</a></h3><p>首先根据react特性决定如果只是this.state来更改值的话，是不会起效的，并且这样的写法是会有警告的； 其次在componentWillUpdate中去使用setState来修改值的话，不一定就会产生死循环；具体要看你是怎么使用setState的，如果只是传入一个对象的话，那么是会产生死循环的；但是如果传入一个函数的话：(preState,props)=&gt;{}，可以通过条件来避免死循环；也就是说在条件满足的情况下，才会进行修改来重渲染，否则就不修改，相应的就不会重渲染，也就不存在会一直触发componentWillUpdate函数</p><h3 id="react-说说你对react的渲染原理的理解" tabindex="-1">[react] 说说你对React的渲染原理的理解 <a class="header-anchor" href="#react-说说你对react的渲染原理的理解" aria-label="Permalink to &quot;\\[react] 说说你对React的渲染原理的理解&quot;">​</a></h3><p>1.单向数据流。React是一个MVVM框架，简单来说是在MVC的模式下在前端部分拆分出数据层和视图层。单向数据流指的是只能由数据层的变化去影响视图层的变化，而不能反过来（除非双向绑定） 2.数据驱动视图。我们无需关注页面的DOM，只需要关注数据即可</p><p>React整个渲染机制就是React会调用React.render()构建一颗DOM树 当state或props改变时,render()会被再次调用构建出另外一颗树,利用Diff算法与之前的树进行对比,找到需要更新的地方进行更新并渲染到页面上,实现按需更新减少对真实DOM的操作,实现性能优化 个人理解这个问题重点在React.render() 和 Diff算法上</p><h3 id="什么渲染劫持" tabindex="-1">什么渲染劫持？ <a class="header-anchor" href="#什么渲染劫持" aria-label="Permalink to &quot;什么渲染劫持？&quot;">​</a></h3><p>高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出，只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。</p><p>实际上，在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可以增强由原组件render函数产生的React元素。</p><p>实际的操作中 通过 操作 state、props 都可以实现渲染劫持</p><h3 id="你有使用过react-intl吗" tabindex="-1">你有使用过React Intl吗？ <a class="header-anchor" href="#你有使用过react-intl吗" aria-label="Permalink to &quot;你有使用过React Intl吗？&quot;">​</a></h3><p>一种react国际化的解决方案</p><h3 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;Context&quot;">​</a></h3><p>context属于一种解决组件间层级过多传递数据的问题，避免了层层嵌套的通过props传递的形式，同时对于不需要使用到redux时，是一种解决方案，关于组件的复用性变差的问题，我觉得是可以通过高阶组件和context配合来解决的，因为react-redux使用的就是这样的形式； 主要的形式：createContext(value)：创建一个context实例；其中的参数为当前数据的默认值，只有没在Provider中指定value时，才会生效； Context.Provider：生产者，数据提供方；通过value属性来定义需要被传递的数据 Context.Consumer：消费者，数据获取方；根据是函数组件还是class组件，有不同的使用形式；class组件可以指定contextType来确定要使用哪一个context对象的值，函数组件需要使用回调函数的形式来获取context的值；需要显示的指定context对象；</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> React, {Component} </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;react&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 首先创建一个 context 对象这里命名为：ThemeContext</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">ThemeContext</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> React.</span><span style="color:#B392F0;">createContext</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;light&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性</span></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">App</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Component</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;</span><span style="color:#79B8FF;">ThemeContext.Provider</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">value</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;dark&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        &lt;</span><span style="color:#79B8FF;">Toolbar</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;/</span><span style="color:#79B8FF;">ThemeContext.Provider</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    )</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 渲染 button 组件的外层包裹的属性</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Toolbar</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;</span><span style="color:#79B8FF;">ThemeButton</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  )</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 在 Toolbar 中渲染的button 组件 返回一个 consumer （消费者）将组件组件的 value 值跨组件传递给 // ThemeButton 组件</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThemeButton</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">props</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#79B8FF;">ThemeContext.Consumer</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      { </span><span style="color:#FFAB70;">theme</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> &lt;</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;"> {</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">props} </span><span style="color:#B392F0;">theme</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{theme}&gt;{theme}&lt;/</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;">&gt; }</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#79B8FF;">ThemeContext.Consumer</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  )</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> React, {Component} </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;react&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 首先创建一个 context 对象这里命名为：ThemeContext</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">ThemeContext</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> React.</span><span style="color:#6F42C1;">createContext</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;light&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 创建一个祖先组件组件 内部使用Provier 这个对象创建一个组件 其中 value 属性是真实传递的属性</span></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">App</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Component</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">render</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#005CC5;">ThemeContext.Provider</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">value</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;dark&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        &lt;</span><span style="color:#005CC5;">Toolbar</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">      &lt;/</span><span style="color:#005CC5;">ThemeContext.Provider</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    )</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 渲染 button 组件的外层包裹的属性</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Toolbar</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#005CC5;">ThemeButton</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  )</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 在 Toolbar 中渲染的button 组件 返回一个 consumer （消费者）将组件组件的 value 值跨组件传递给 // ThemeButton 组件</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThemeButton</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">props</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#005CC5;">ThemeContext.Consumer</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      { </span><span style="color:#E36209;">theme</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> &lt;</span><span style="color:#22863A;">button</span><span style="color:#24292E;"> {</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">props} </span><span style="color:#6F42C1;">theme</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{theme}&gt;{theme}&lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt; }</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/</span><span style="color:#005CC5;">ThemeContext.Consumer</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  )</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="consumer向上找不到provider的时候怎么办" tabindex="-1">Consumer向上找不到Provider的时候怎么办？ <a class="header-anchor" href="#consumer向上找不到provider的时候怎么办" aria-label="Permalink to &quot;Consumer向上找不到Provider的时候怎么办？&quot;">​</a></h3><p>当consumer向上层找不到provider时，此时就会取创建context时传给createContext的那个值，也就是当前context对象的默认值，在定义provider时的value中的值不是默认值，而是表示需要被传递的值</p><h3 id="有使用过consumer吗" tabindex="-1">有使用过Consumer吗 <a class="header-anchor" href="#有使用过consumer吗" aria-label="Permalink to &quot;有使用过Consumer吗&quot;">​</a></h3><p>Consumer主要用来在使用context的过程中，来获取上层provider的值，通过定义组件contextType的值来指定要获取的是哪个context，找到当前context对应的最近的一个provider，取到value属性的值，如果没有定义，那么就会取到创建当前context时的传入值</p><h3 id="举例说明react的插槽有哪些运用场景" tabindex="-1">举例说明React的插槽有哪些运用场景？ <a class="header-anchor" href="#举例说明react的插槽有哪些运用场景" aria-label="Permalink to &quot;举例说明React的插槽有哪些运用场景？&quot;">​</a></h3><p>我觉得这里的插槽，指的应该是组合组件，而不是portal(传送门)，因为对比vue中的插槽，只是父组件在子组件中间加入一系列的内容，然后子组件可以自己判断显示逻辑，所以props.children更符合插槽的定义； portal可以将内容插入到除了父节点的dom之外的地方去渲染，所以modal是一个通过portal实现的典型例子；并且对于事件绑定，因为使用了事件冒泡，所以并不用担心被渲染到父组件结构之外的内容，不能去监听事件</p><h3 id="你有用过react的插槽-portals-吗-怎么用" tabindex="-1">你有用过React的插槽(Portals)吗？怎么用？ <a class="header-anchor" href="#你有用过react的插槽-portals-吗-怎么用" aria-label="Permalink to &quot;你有用过React的插槽(Portals)吗？怎么用？&quot;">​</a></h3><p>1、首先简单的介绍下react中的插槽（Portals），通过ReactDOM.createPortal(child, container)创建，是ReactDOM提供的接口，可以实现将子节点渲染到父组件DOM层次结构之外的DOM节点。 2、第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。 3、对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框。所以一般react组件里的模态框，就是这样实现的。</p><h3 id="react-filer-可以理解为" tabindex="-1">React Filer 可以理解为？ <a class="header-anchor" href="#react-filer-可以理解为" aria-label="Permalink to &quot;React Filer 可以理解为？&quot;">​</a></h3><p>React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。</p>`,32),e=[o];function t(c,r,E,y,i,d){return a(),n("div",null,e)}const m=s(p,[["render",t]]);export{h as __pageData,m as default};
